<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Introduction"><title>wtfm_rs - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="wtfm_rs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.93.0 (254b59607 2026-01-19)" data-channel="1.93.0" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-a3946164.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-a410ff4d.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate wtfm_rs</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../wtfm_rs/index.html">wtfm_rs</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#introduction" title="Introduction">Introduction</a></li><li><a href="#professional-rustdoc-rabbit-holes" title="Professional rustdoc rabbit holes">Professional rustdoc rabbit holes</a></li><li><a href="#doctest" title="Doctest">Doctest</a></li><li><a href="#assert-driven-development" title="assert! driven development">assert! driven development</a></li><li><a href="#println-driven-development" title="println! driven development">println! driven development</a></li><li><a href="#external-crates" title="External crates">External crates</a></li><li><a href="#get-the-ouput-from-echo-hello-world" title="Get the ouput from echo Hello, world!">Get the ouput from echo Hello, world!</a></li><li><a href="#same-code-in-three-crates" title="Same code in three crates">Same code in three crates</a></li><li><a href="#why-do-we-do-this" title="Why do we do this?">Why do we do this?</a></li><li><a href="#devil-is-in-the-details" title="Devil is in the details">Devil is in the details</a></li></ul><h3><a href="#functions">Crate Items</a></h3><ul class="block"><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>wtfm_rs</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/wtfm_rs/lib.rs.html#1-283">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="introduction"><a class="doc-anchor" href="#introduction">§</a>Introduction</h2>
<p>WTFM is <a href="https://en.wikipedia.org/wiki/RTFM">RTFM</a> in Rust.</p>
<p>To master an ecosystem as broad and deep as Rust in a short period of time,
we might want to turn R into W, dive deep by writing our own
<a href="https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html">doctests</a> iteratively until we find the solution to our problem.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"WTFM"</span>, <span class="string">"RTFM"</span>.replace(<span class="string">"R"</span>, <span class="string">"W"</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22WTFM%22,+%22RTFM%22.replace(%22R%22,+%22W%22));%0A%7D&amp;edition=2024"></a></div>
<p>Doctests can be good “paper trails” of our thought process.</p>
<p>We can also learn about the throught process of other crates by “reviewing”
them with our own doctests.</p>
<h2 id="professional-rustdoc-rabbit-holes"><a class="doc-anchor" href="#professional-rustdoc-rabbit-holes">§</a>Professional rustdoc rabbit holes</h2>
<p>Be prepared to fall into rabbit holes of rustdoc and get out
where and when you need to. This is a skill to be learned.
We are programmers, not librarians.</p>
<p><a href="https://rust-lang.github.io/api-guidelines/documentation.html">https://rust-lang.github.io/api-guidelines/documentation.html</a></p>
<h2 id="doctest"><a class="doc-anchor" href="#doctest">§</a>Doctest</h2>
<p>If <code>cargo test --doc</code> passed, we will have have output like</p>
<div class="example-wrap"><pre class="language-text"><code>all doctests ran in 0.70s; merged doctests compilation took 0.33s</code></pre></div>
<p>There is no need to check each one of them in playground but we can explore
further by tinkering with them in the plalyground.
(That is why we call it playground.)</p>
<p>Since doctests are merged and compiled into one binary, we want to make sure
they don’t interfere with each other. Since doctests are not the real part
of the code, we can have cleanup code in the libray body or unit test body.
We can see how the source code progress this way.</p>
<h2 id="assert-driven-development"><a class="doc-anchor" href="#assert-driven-development">§</a><a href="https://doc.rust-lang.org/1.93.0/core/macro.assert.html" title="macro core::assert">assert!</a> driven development</h2>
<p>Be prepared to <a href="https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html">RTFM</a> <a href="https://doc.rust-lang.org/1.93.0/std/index.html" title="mod std">std</a>.</p>
<p>Let’s start with a trivial rust program using
macro <a href="https://doc.rust-lang.org/1.93.0/core/macro.assert.html" title="macro core::assert">assert!</a> and primitive <a href="https://doc.rust-lang.org/1.93.0/std/primitive.bool.html" title="primitive bool">true</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(<span class="bool-val">true</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert!(true);%0A%7D&amp;edition=2024"></a></div>
<p>We can wrap it with a function <code>assert_true_v1</code> and call it in the
same doctest block:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>assert_true_v1() {
    <span class="macro">assert!</span>(<span class="bool-val">true</span>);
}
assert_true_v1();</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+assert_true_v1()+%7B%0A++++++++assert!(true);%0A++++%7D%0A++++assert_true_v1();%0A%7D&amp;edition=2024"></a></div>
<p>To make it a little be more complicated we can wrap <a href="https://doc.rust-lang.org/1.93.0/std/primitive.bool.html" title="primitive bool">true</a> with
a function as well.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>return_true() -&gt; bool { <span class="bool-val">true </span>}
<span class="macro">assert!</span>(return_true());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+return_true()+-%3E+bool+%7B+true+%7D%0A++++assert!(return_true());%0A%7D&amp;edition=2024"></a></div>
<p>The version 2 of <code>asser_true</code> can be</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>assert_true_v2() {
    <span class="macro">assert!</span>(return_true());
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++fn+assert_true_v2()+%7B%0A++++++++assert!(return_true());%0A++++%7D%0A%7D&amp;edition=2024"></a></div>
<p>The reason the doctest above failed is <code>return_true</code> is out of scope.</p>
<p>Let’s put function <a href="fn.return_true.html" title="fn wtfm_rs::return_true">return_true</a> in the crate,
following works in <code>cargo test --doc</code> but
would fail in playground because playground can’t resolve our crate.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>wtfm_rs::return_true;
<span class="kw">fn </span>assert_true_v2() {
    <span class="macro">assert!</span>(return_true());
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23wtfm_rs;%0Afn+main()+%7B%0A++++use+wtfm_rs::return_true;%0A++++fn+assert_true_v2()+%7B%0A++++++++assert!(return_true());%0A++++%7D%0A%7D&amp;edition=2024"></a></div>
<p>We can add similar test to the unit test of this crate (see the source code)
<code>cargo test</code> will capture all of them.</p>
<div class="example-wrap"><pre class="language-text"><code> cargo test
   Finished `test` profile [unoptimized + debuginfo] target(s) in 0.00s
    Running unittests src/lib.rs (target/debug/deps/wtfm_rs-ee0d1b96bcb289bd)

running 1 test
test assert_true_v3 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

  Doc-tests wtfm_rs

running 4 tests
test src/lib.rs - (line 51) ... ok
test src/lib.rs - (line 73) ... ok
test src/lib.rs - (line 58) ... ok
test src/lib.rs - (line 11) ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 1 test
test src/lib.rs - (line 64) - compile fail ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.03s

all doctests ran in 0.45s; merged doctests compilation took 0.21s</code></pre></div><h2 id="println-driven-development"><a class="doc-anchor" href="#println-driven-development">§</a><a href="https://doc.rust-lang.org/1.93.0/std/macro.println.html" title="macro std::println">println!</a> driven development</h2>
<p>If we add <a href="https://doc.rust-lang.org/1.93.0/std/macro.println.html" title="macro std::println">println!</a> to the doctest</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>wtfm_rs::return_true;
<span class="kw">fn </span>assert_true_v3() {
    <span class="macro">assert!</span>(return_true());
    <span class="macro">println!</span>(<span class="string">"{}"</span>, return_true());
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23wtfm_rs;%0Afn+main()+%7B%0A++++use+wtfm_rs::return_true;%0A++++fn+assert_true_v3()+%7B%0A++++++++assert!(return_true());%0A++++++++println!(%22%7B%7D%22,+return_true());%0A++++%7D%0A%7D&amp;edition=2024"></a></div>
<p><code>cargo test</code> will not have any println feedback.</p>
<div class="example-wrap"><pre class="language-text"><code>test src/lib.rs - (line 110) ... ok</code></pre></div>
<p>So <code>println!</code> driven development wouldn’t work with doctests.</p>
<p>To do <code>println!</code> driven development, we can use example crates.</p>
<div class="example-wrap"><pre class="language-text"><code>cargo doc --examples</code></pre></div><div class="example-wrap"><pre class="language-text"><code>cargo run --example example-assert-true
   Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
    Running `target/debug/examples/example-assert-true`
true</code></pre></div><h2 id="external-crates"><a class="doc-anchor" href="#external-crates">§</a>External crates</h2>
<p>Rustdoc is organized by crate and we can also bring external crates in
via <code>Cargo.toml</code></p>
<div class="example-wrap"><pre class="language-toml"><code>[package]
name = &quot;wtfm-rs&quot;
version = &quot;0.1.0&quot;
edition = &quot;2024&quot;

[dependencies]
wtfm-rs-hello-world = { git = &quot;https://github.com/wtfm-rs/wtfm-rs.github.io&quot;, branch = &quot;hello-world&quot;, version = &quot;0.1.0&quot; }</code></pre></div>
<p>In this case, we pull <a href="../wtfm_rs_hello_world/index.html" title="mod wtfm_rs_hello_world">wtfm_rs_hello_world</a> crate from
<a href="https://github.com/wtfm-rs/wtfm-rs.github.io/tree/hello-world">https://github.com/wtfm-rs/wtfm-rs.github.io/tree/hello-world</a>.</p>
<p>We can use the function <code>hello_world()</code> from it</p>
<div class="example-wrap"><pre class="language-text"><code>pub use wtfm_rs_hello_world::hello_world;</code></pre></div>
<p>and use it as <code>wtfm_rs::hello_world</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>wtfm_rs::hello_world;
<span class="macro">assert_eq!</span>(hello_world(), <span class="string">"Hello, world!"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23wtfm_rs;%0Afn+main()+%7B%0A++++use+wtfm_rs::hello_world;%0A++++assert_eq!(hello_world(),+%22Hello,+world!%22);%0A%7D&amp;edition=2024"></a></div>
<p>This will fail in playwright as before, but will pass <code>cargo test</code>.</p>
<h2 id="get-the-ouput-from-echo-hello-world"><a class="doc-anchor" href="#get-the-ouput-from-echo-hello-world">§</a>Get the ouput from echo Hello, world!</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::process::Command;
<span class="kw">let </span>output = Command::new(<span class="string">"echo"</span>)
       .arg(<span class="string">"Hello,"</span>)
       .arg(<span class="string">"world!"</span>)
       .output()
       .expect(<span class="string">"Failed to execute command"</span>);
<span class="kw">let </span>output_1 = String::from_utf8_lossy(<span class="kw-2">&amp;</span>output.stdout).to_string();
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{}"</span>, output_1), <span class="string">"Hello, world!\n"</span>);
<span class="kw">let </span>output_2 = String::from_utf8(output.stdout).expect(<span class="string">"Format error"</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{}"</span>, output_2), <span class="string">"Hello, world!\n"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::process::Command;%0A++++let+output+=+Command::new(%22echo%22)%0A+++++++++++.arg(%22Hello,%22)%0A+++++++++++.arg(%22world!%22)%0A+++++++++++.output()%0A+++++++++++.expect(%22Failed+to+execute+command%22);%0A++++let+output_1+=+String::from_utf8_lossy(%26output.stdout).to_string();%0A++++assert_eq!(format!(%22%7B%7D%22,+output_1),+%22Hello,+world!%5Cn%22);%0A++++let+output_2+=+String::from_utf8(output.stdout).expect(%22Format+error%22);%0A++++assert_eq!(format!(%22%7B%7D%22,+output_2),+%22Hello,+world!%5Cn%22);%0A%7D&amp;edition=2024"></a></div>
<p><a href="https://doc.rust-lang.org/1.93.0/std/process/struct.Command.html" title="struct std::process::Command">std::process::Command</a></p>
<p><a href="https://doc.rust-lang.org/1.93.0/alloc/string/struct.String.html#method.from_utf8" title="associated function alloc::string::String::from_utf8">String::from_utf8</a></p>
<p><a href="https://doc.rust-lang.org/1.93.0/alloc/string/struct.String.html#method.from_utf8_lossy" title="associated function alloc::string::String::from_utf8_lossy">String::from_utf8_lossy</a></p>
<h2 id="same-code-in-three-crates"><a class="doc-anchor" href="#same-code-in-three-crates">§</a>Same code in three crates</h2>
<ol>
<li>
<p>We started it as doctest in this crate <a href="./index.html"><code>wtfm_rs</code></a>.</p>
</li>
<li>
<p>We copy and paste it to an example crate
<a href="../example_echo_hello_world/index.html"><code>example_echo_hello_world</code></a>.</p>
</li>
<li>
<p>We create an external crate <a href="../wtfm_rs_echo_hello_world/index.html" title="mod wtfm_rs_echo_hello_world">wtfm_rs_echo_hello_world</a>
in a <a href="https://github.com/wtfm-rs/wtfm-rs.github.io/tree/refs/heads/echo-hello-world">branch</a> and pull it in with <code>Cargo.toml</code>.:</p>
</li>
</ol>
<div class="example-wrap"><pre class="language-text"><code>wtfm-rs-echo-hello-world = { git = &quot;https://github.com/wtfm-rs/wtfm-rs.github.io&quot;, branch = &quot;echo-hello-world&quot;, version = &quot;0.1.0&quot; }</code></pre></div><h2 id="why-do-we-do-this"><a class="doc-anchor" href="#why-do-we-do-this">§</a>Why do we do this?</h2>
<p>This allows us to explore with controlled dependenices.
Doctests in a crate will not becoming the dependency of any crate so we are
safe to modify and test out ideas.
Same with example crates that allows us to add <code>fn main</code> but can only be
called via <code>cargto run --example ...</code>.</p>
<p>Once the code is “published” in <a href="../wtfm_rs_echo_hello_world/index.html" title="mod wtfm_rs_echo_hello_world">wtfm_rs_echo_hello_world</a>,
and became part of the dependency tree, it can be called by us
(Rollowing code will not run in Playground becuase of scope.)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>wtfm_rs_echo_hello_world::echo_hello_world;
<span class="macro">assert_eq!</span>(echo_hello_world(), <span class="string">"Hello, world!\n"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23wtfm_rs;%0Afn+main()+%7B%0A++++use+wtfm_rs_echo_hello_world::echo_hello_world;%0A++++assert_eq!(echo_hello_world(),+%22Hello,+world!%5Cn%22);%0A%7D&amp;edition=2024"></a></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>wtfm_rs::echo_hello_world;
<span class="macro">assert_eq!</span>(echo_hello_world(), <span class="string">"Hello, world!\n"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23wtfm_rs;%0Afn+main()+%7B%0A++++use+wtfm_rs::echo_hello_world;%0A++++assert_eq!(echo_hello_world(),+%22Hello,+world!%5Cn%22);%0A%7D&amp;edition=2024"></a></div><div class="example-wrap"><pre class="language-text"><code>cargo tree
wtfm-rs v0.1.0 (/Users/sam/github/wtfm-rs/wtfm-rs.github.io)
├── wtfm-rs-echo-hello-world v0.1.0 (https://github.com/wtfm-rs/wtfm-rs.github.io?branch=echo-hello-world#9244775f)
└── wtfm-rs-hello-world v0.1.0 (https://github.com/wtfm-rs/wtfm-rs.github.io?branch=hello-world#98fb5c7e)</code></pre></div>
<p>By design, none of these WTFM crates should end up in production.
They are “paper trails” of thought process.
The purpose of reading, writing, and testing them is to force us to
think and reason the choices we made in the context of rust toolchain,
i.e., <code>cargo doc, cargo test, cargo run ...</code> .</p>
<p>We are free to change our mind.</p>
<h2 id="devil-is-in-the-details"><a class="doc-anchor" href="#devil-is-in-the-details">§</a>Devil is in the details</h2>
<p>We have been distracted by the toolchain rabbit holes and it is time
to get back to our main trail. Let’s take a look at following code again.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::process::Command;
<span class="kw">let </span>output = Command::new(<span class="string">"echo"</span>)
       .arg(<span class="string">"Hello,"</span>)
       .arg(<span class="string">"world!"</span>)
       .output()
       .expect(<span class="string">"Failed to execute command"</span>);
<span class="kw">let </span>output_1 = String::from_utf8_lossy(<span class="kw-2">&amp;</span>output.stdout).to_string();
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{}"</span>, output_1), <span class="string">"Hello, world!\n"</span>);
<span class="kw">let </span>output_2 = String::from_utf8(output.stdout).expect(<span class="string">"Format error"</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{}"</span>, output_2), <span class="string">"Hello, world!\n"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::process::Command;%0A++++let+output+=+Command::new(%22echo%22)%0A+++++++++++.arg(%22Hello,%22)%0A+++++++++++.arg(%22world!%22)%0A+++++++++++.output()%0A+++++++++++.expect(%22Failed+to+execute+command%22);%0A++++let+output_1+=+String::from_utf8_lossy(%26output.stdout).to_string();%0A++++assert_eq!(format!(%22%7B%7D%22,+output_1),+%22Hello,+world!%5Cn%22);%0A++++let+output_2+=+String::from_utf8(output.stdout).expect(%22Format+error%22);%0A++++assert_eq!(format!(%22%7B%7D%22,+output_2),+%22Hello,+world!%5Cn%22);%0A%7D&amp;edition=2024"></a></div>
<p>If we switch <code>output_1</code> and <code>output_2</code>, it won’t comile</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::process::Command;
<span class="kw">let </span>output = Command::new(<span class="string">"echo"</span>)
       .arg(<span class="string">"Hello,"</span>)
       .arg(<span class="string">"world!"</span>)
       .output()
       .expect(<span class="string">"Failed to execute command"</span>);
<span class="kw">let </span>output_2 = String::from_utf8(output.stdout).expect(<span class="string">"Format error"</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{}"</span>, output_2), <span class="string">"Hello, world!\n"</span>);
<span class="kw">let </span>output_1 = String::from_utf8_lossy(<span class="kw-2">&amp;</span>output.stdout).to_string();
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{}"</span>, output_1), <span class="string">"Hello, world!\n"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::process::Command;%0A++++let+output+=+Command::new(%22echo%22)%0A+++++++++++.arg(%22Hello,%22)%0A+++++++++++.arg(%22world!%22)%0A+++++++++++.output()%0A+++++++++++.expect(%22Failed+to+execute+command%22);%0A++++let+output_2+=+String::from_utf8(output.stdout).expect(%22Format+error%22);%0A++++assert_eq!(format!(%22%7B%7D%22,+output_2),+%22Hello,+world!%5Cn%22);%0A++++let+output_1+=+String::from_utf8_lossy(%26output.stdout).to_string();%0A++++assert_eq!(format!(%22%7B%7D%22,+output_1),+%22Hello,+world!%5Cn%22);%0A%7D&amp;edition=2024"></a></div></div></details><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.echo_hello_world.html" title="fn wtfm_rs::echo_hello_world">echo_<wbr>hello_<wbr>world</a></dt><dt><a class="fn" href="fn.hello_world.html" title="fn wtfm_rs::hello_world">hello_<wbr>world</a></dt><dt><a class="fn" href="fn.return_true.html" title="fn wtfm_rs::return_true">return_<wbr>true</a></dt></dl></section></div></main></body></html>